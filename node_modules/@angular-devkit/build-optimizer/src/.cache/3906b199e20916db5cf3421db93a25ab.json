{"remainingRequest":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/util/Immediate.js","dependencies":[{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/util/Immediate.js","mtime":1531331967000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/cache-loader/dist/cjs.js","mtime":1531332486000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\nSome credit for this helper goes to http://github.com/YuzuJS/setImmediate\n*/\nimport { root } from './root';\nexport class ImmediateDefinition {\n    constructor(root) {\n        this.root = root;\n        if (root.setImmediate && typeof root.setImmediate === 'function') {\n            this.setImmediate = root.setImmediate.bind(root);\n            this.clearImmediate = root.clearImmediate.bind(root);\n        }\n        else {\n            this.nextHandle = 1;\n            this.tasksByHandle = {};\n            this.currentlyRunningATask = false;\n            // Don't get fooled by e.g. browserify environments.\n            if (this.canUseProcessNextTick()) {\n                // For Node.js before 0.9\n                this.setImmediate = this.createProcessNextTickSetImmediate();\n            }\n            else if (this.canUsePostMessage()) {\n                // For non-IE10 modern browsers\n                this.setImmediate = this.createPostMessageSetImmediate();\n            }\n            else if (this.canUseMessageChannel()) {\n                // For web workers, where supported\n                this.setImmediate = this.createMessageChannelSetImmediate();\n            }\n            else if (this.canUseReadyStateChange()) {\n                // For IE 6â€“8\n                this.setImmediate = this.createReadyStateChangeSetImmediate();\n            }\n            else {\n                // For older browsers\n                this.setImmediate = this.createSetTimeoutSetImmediate();\n            }\n            let ci = function clearImmediate(handle) {\n                delete clearImmediate.instance.tasksByHandle[handle];\n            };\n            ci.instance = this;\n            this.clearImmediate = ci;\n        }\n    }\n    identify(o) {\n        return this.root.Object.prototype.toString.call(o);\n    }\n    canUseProcessNextTick() {\n        return this.identify(this.root.process) === '[object process]';\n    }\n    canUseMessageChannel() {\n        return Boolean(this.root.MessageChannel);\n    }\n    canUseReadyStateChange() {\n        const document = this.root.document;\n        return Boolean(document && 'onreadystatechange' in document.createElement('script'));\n    }\n    canUsePostMessage() {\n        const root = this.root;\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `root.postMessage` means something completely different and can't be used for this purpose.\n        if (root.postMessage && !root.importScripts) {\n            let postMessageIsAsynchronous = true;\n            let oldOnMessage = root.onmessage;\n            root.onmessage = function () {\n                postMessageIsAsynchronous = false;\n            };\n            root.postMessage('', '*');\n            root.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n        return false;\n    }\n    // This function accepts the same arguments as setImmediate, but\n    // returns a function that requires no arguments.\n    partiallyApplied(handler, ...args) {\n        let fn = function result() {\n            const { handler, args } = result;\n            if (typeof handler === 'function') {\n                handler.apply(undefined, args);\n            }\n            else {\n                (new Function('' + handler))();\n            }\n        };\n        fn.handler = handler;\n        fn.args = args;\n        return fn;\n    }\n    addFromSetImmediateArguments(args) {\n        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);\n        return this.nextHandle++;\n    }\n    createProcessNextTickSetImmediate() {\n        let fn = function setImmediate() {\n            const { instance } = setImmediate;\n            let handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    }\n    createPostMessageSetImmediate() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n        const root = this.root;\n        let messagePrefix = 'setImmediate$' + root.Math.random() + '$';\n        let onGlobalMessage = function globalMessageHandler(event) {\n            const instance = globalMessageHandler.instance;\n            if (event.source === root &&\n                typeof event.data === 'string' &&\n                event.data.indexOf(messagePrefix) === 0) {\n                instance.runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n        onGlobalMessage.instance = this;\n        root.addEventListener('message', onGlobalMessage, false);\n        let fn = function setImmediate() {\n            const { messagePrefix, instance } = setImmediate;\n            let handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.postMessage(messagePrefix + handle, '*');\n            return handle;\n        };\n        fn.instance = this;\n        fn.messagePrefix = messagePrefix;\n        return fn;\n    }\n    runIfPresent(handle) {\n        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (this.currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // 'too much recursion' error.\n            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);\n        }\n        else {\n            let task = this.tasksByHandle[handle];\n            if (task) {\n                this.currentlyRunningATask = true;\n                try {\n                    task();\n                }\n                finally {\n                    this.clearImmediate(handle);\n                    this.currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n    createMessageChannelSetImmediate() {\n        let channel = new this.root.MessageChannel();\n        channel.port1.onmessage = (event) => {\n            let handle = event.data;\n            this.runIfPresent(handle);\n        };\n        let fn = function setImmediate() {\n            const { channel, instance } = setImmediate;\n            let handle = instance.addFromSetImmediateArguments(arguments);\n            channel.port2.postMessage(handle);\n            return handle;\n        };\n        fn.channel = channel;\n        fn.instance = this;\n        return fn;\n    }\n    createReadyStateChangeSetImmediate() {\n        let fn = function setImmediate() {\n            const instance = setImmediate.instance;\n            const root = instance.root;\n            const doc = root.document;\n            const html = doc.documentElement;\n            let handle = instance.addFromSetImmediateArguments(arguments);\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            let script = doc.createElement('script');\n            script.onreadystatechange = () => {\n                instance.runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    }\n    createSetTimeoutSetImmediate() {\n        let fn = function setImmediate() {\n            const instance = setImmediate.instance;\n            let handle = instance.addFromSetImmediateArguments(arguments);\n            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);\n            return handle;\n        };\n        fn.instance = this;\n        return fn;\n    }\n}\nexport const Immediate = new ImmediateDefinition(root);\n//# sourceMappingURL=Immediate.js.map",null]}