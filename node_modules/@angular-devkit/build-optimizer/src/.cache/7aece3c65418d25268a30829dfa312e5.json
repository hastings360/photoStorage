{"remainingRequest":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/operators/bufferToggle.js","dependencies":[{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/operators/bufferToggle.js","mtime":1531331967000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/cache-loader/dist/cjs.js","mtime":1531332486000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { Subscription } from '../Subscription';\nimport { subscribeToResult } from '../util/subscribeToResult';\nimport { OuterSubscriber } from '../OuterSubscriber';\n/**\n * Buffers the source Observable values starting from an emission from\n * `openings` and ending when the output of `closingSelector` emits.\n *\n * <span class=\"informal\">Collects values from the past as an array. Starts\n * collecting only when `opening` emits, and calls the `closingSelector`\n * function to get an Observable that tells when to close the buffer.</span>\n *\n * <img src=\"./img/bufferToggle.png\" width=\"100%\">\n *\n * Buffers values from the source by opening the buffer via signals from an\n * Observable provided to `openings`, and closing and sending the buffers when\n * a Subscribable or Promise returned by the `closingSelector` function emits.\n *\n * @example <caption>Every other second, emit the click events from the next 500ms</caption>\n * var clicks = Rx.Observable.fromEvent(document, 'click');\n * var openings = Rx.Observable.interval(1000);\n * var buffered = clicks.bufferToggle(openings, i =>\n *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()\n * );\n * buffered.subscribe(x => console.log(x));\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n * @see {@link bufferTime}\n * @see {@link bufferWhen}\n * @see {@link windowToggle}\n *\n * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new\n * buffers.\n * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes\n * the value emitted by the `openings` observable and returns a Subscribable or Promise,\n * which, when it emits, signals that the associated buffer should be emitted\n * and cleared.\n * @return {Observable<T[]>} An observable of arrays of buffered values.\n * @method bufferToggle\n * @owner Observable\n */\nexport function bufferToggle(openings, closingSelector) {\n    return function bufferToggleOperatorFunction(source) {\n        return source.lift(new BufferToggleOperator(openings, closingSelector));\n    };\n}\nclass BufferToggleOperator {\n    constructor(openings, closingSelector) {\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass BufferToggleSubscriber extends OuterSubscriber {\n    constructor(destination, openings, closingSelector) {\n        super(destination);\n        this.openings = openings;\n        this.closingSelector = closingSelector;\n        this.contexts = [];\n        this.add(subscribeToResult(this, openings));\n    }\n    _next(value) {\n        const contexts = this.contexts;\n        const len = contexts.length;\n        for (let i = 0; i < len; i++) {\n            contexts[i].buffer.push(value);\n        }\n    }\n    _error(err) {\n        const contexts = this.contexts;\n        while (contexts.length > 0) {\n            const context = contexts.shift();\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        super._error(err);\n    }\n    _complete() {\n        const contexts = this.contexts;\n        while (contexts.length > 0) {\n            const context = contexts.shift();\n            this.destination.next(context.buffer);\n            context.subscription.unsubscribe();\n            context.buffer = null;\n            context.subscription = null;\n        }\n        this.contexts = null;\n        super._complete();\n    }\n    notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);\n    }\n    notifyComplete(innerSub) {\n        this.closeBuffer(innerSub.context);\n    }\n    openBuffer(value) {\n        try {\n            const closingSelector = this.closingSelector;\n            const closingNotifier = closingSelector.call(this, value);\n            if (closingNotifier) {\n                this.trySubscribe(closingNotifier);\n            }\n        }\n        catch (err) {\n            this._error(err);\n        }\n    }\n    closeBuffer(context) {\n        const contexts = this.contexts;\n        if (contexts && context) {\n            const { buffer, subscription } = context;\n            this.destination.next(buffer);\n            contexts.splice(contexts.indexOf(context), 1);\n            this.remove(subscription);\n            subscription.unsubscribe();\n        }\n    }\n    trySubscribe(closingNotifier) {\n        const contexts = this.contexts;\n        const buffer = [];\n        const subscription = new Subscription();\n        const context = { buffer, subscription };\n        contexts.push(context);\n        const innerSubscription = subscribeToResult(this, closingNotifier, context);\n        if (!innerSubscription || innerSubscription.closed) {\n            this.closeBuffer(context);\n        }\n        else {\n            innerSubscription.context = context;\n            this.add(innerSubscription);\n            subscription.add(innerSubscription);\n        }\n    }\n}\n//# sourceMappingURL=bufferToggle.js.map",null]}