{"remainingRequest":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/observable/PairsObservable.js","dependencies":[{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/observable/PairsObservable.js","mtime":1531331966000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/cache-loader/dist/cjs.js","mtime":1531332486000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { Observable } from '../Observable';\nfunction dispatch(state) {\n    const { obj, keys, length, index, subscriber } = state;\n    if (index === length) {\n        subscriber.complete();\n        return;\n    }\n    const key = keys[index];\n    subscriber.next([key, obj[key]]);\n    state.index = index + 1;\n    this.schedule(state);\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class PairsObservable extends Observable {\n    constructor(obj, scheduler) {\n        super();\n        this.obj = obj;\n        this.scheduler = scheduler;\n        this.keys = Object.keys(obj);\n    }\n    /**\n     * Convert an object into an observable sequence of [key, value] pairs\n     * using an optional IScheduler to enumerate the object.\n     *\n     * @example <caption>Converts a javascript object to an Observable</caption>\n     * var obj = {\n     *   foo: 42,\n     *   bar: 56,\n     *   baz: 78\n     * };\n     *\n     * var source = Rx.Observable.pairs(obj);\n     *\n     * var subscription = source.subscribe(\n     *   function (x) {\n     *     console.log('Next: %s', x);\n     *   },\n     *   function (err) {\n     *     console.log('Error: %s', err);\n     *   },\n     *   function () {\n     *     console.log('Completed');\n     *   });\n     *\n     * @param {Object} obj The object to inspect and turn into an\n     * Observable sequence.\n     * @param {Scheduler} [scheduler] An optional IScheduler to run the\n     * enumeration of the input sequence on.\n     * @returns {(Observable<Array<string | T>>)} An observable sequence of\n     * [key, value] pairs from the object.\n     */\n    static create(obj, scheduler) {\n        return new PairsObservable(obj, scheduler);\n    }\n    /** @deprecated internal use only */ _subscribe(subscriber) {\n        const { keys, scheduler } = this;\n        const length = keys.length;\n        if (scheduler) {\n            return scheduler.schedule(dispatch, 0, {\n                obj: this.obj, keys, length, index: 0, subscriber\n            });\n        }\n        else {\n            for (let idx = 0; idx < length; idx++) {\n                const key = keys[idx];\n                subscriber.next([key, this.obj[key]]);\n            }\n            subscriber.complete();\n        }\n    }\n}\n//# sourceMappingURL=PairsObservable.js.map",null]}