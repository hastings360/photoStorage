{"remainingRequest":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/operators/repeatWhen.js","dependencies":[{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/operators/repeatWhen.js","mtime":1531331967000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/cache-loader/dist/cjs.js","mtime":1531332486000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { Subject } from '../Subject';\nimport { tryCatch } from '../util/tryCatch';\nimport { errorObject } from '../util/errorObject';\nimport { OuterSubscriber } from '../OuterSubscriber';\nimport { subscribeToResult } from '../util/subscribeToResult';\n/**\n * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source\n * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable\n * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise\n * this method will resubscribe to the source Observable.\n *\n * <img src=\"./img/repeatWhen.png\" width=\"100%\">\n *\n * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with\n * which a user can `complete` or `error`, aborting the repetition.\n * @return {Observable} The source Observable modified with repeat logic.\n * @method repeatWhen\n * @owner Observable\n */\nexport function repeatWhen(notifier) {\n    return (source) => source.lift(new RepeatWhenOperator(notifier));\n}\nclass RepeatWhenOperator {\n    constructor(notifier) {\n        this.notifier = notifier;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));\n    }\n}\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @ignore\n * @extends {Ignored}\n */\nclass RepeatWhenSubscriber extends OuterSubscriber {\n    constructor(destination, notifier, source) {\n        super(destination);\n        this.notifier = notifier;\n        this.source = source;\n        this.sourceIsBeingSubscribedTo = true;\n    }\n    notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {\n        this.sourceIsBeingSubscribedTo = true;\n        this.source.subscribe(this);\n    }\n    notifyComplete(innerSub) {\n        if (this.sourceIsBeingSubscribedTo === false) {\n            return super.complete();\n        }\n    }\n    complete() {\n        this.sourceIsBeingSubscribedTo = false;\n        if (!this.isStopped) {\n            if (!this.retries) {\n                this.subscribeToRetries();\n            }\n            if (!this.retriesSubscription || this.retriesSubscription.closed) {\n                return super.complete();\n            }\n            this._unsubscribeAndRecycle();\n            this.notifications.next();\n        }\n    }\n    /** @deprecated internal use only */ _unsubscribe() {\n        const { notifications, retriesSubscription } = this;\n        if (notifications) {\n            notifications.unsubscribe();\n            this.notifications = null;\n        }\n        if (retriesSubscription) {\n            retriesSubscription.unsubscribe();\n            this.retriesSubscription = null;\n        }\n        this.retries = null;\n    }\n    /** @deprecated internal use only */ _unsubscribeAndRecycle() {\n        const { notifications, retries, retriesSubscription } = this;\n        this.notifications = null;\n        this.retries = null;\n        this.retriesSubscription = null;\n        super._unsubscribeAndRecycle();\n        this.notifications = notifications;\n        this.retries = retries;\n        this.retriesSubscription = retriesSubscription;\n        return this;\n    }\n    subscribeToRetries() {\n        this.notifications = new Subject();\n        const retries = tryCatch(this.notifier)(this.notifications);\n        if (retries === errorObject) {\n            return super.complete();\n        }\n        this.retries = retries;\n        this.retriesSubscription = subscribeToResult(this, retries);\n    }\n}\n//# sourceMappingURL=repeatWhen.js.map",null]}