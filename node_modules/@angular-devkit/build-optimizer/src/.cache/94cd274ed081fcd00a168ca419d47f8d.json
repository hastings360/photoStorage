{"remainingRequest":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/testing/TestScheduler.js","dependencies":[{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/testing/TestScheduler.js","mtime":1531331967000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/cache-loader/dist/cjs.js","mtime":1531332486000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nconst defaultMaxFrame = 750;\nexport class TestScheduler extends VirtualTimeScheduler {\n    constructor(assertDeepEqual) {\n        super(VirtualAction, defaultMaxFrame);\n        this.assertDeepEqual = assertDeepEqual;\n        this.hotObservables = [];\n        this.coldObservables = [];\n        this.flushTests = [];\n    }\n    createTime(marbles) {\n        const indexOf = marbles.indexOf('|');\n        if (indexOf === -1) {\n            throw new Error('marble diagram for time should have a completion marker \"|\"');\n        }\n        return indexOf * TestScheduler.frameTimeFactor;\n    }\n    createColdObservable(marbles, values, error) {\n        if (marbles.indexOf('^') !== -1) {\n            throw new Error('cold observable cannot have subscription offset \"^\"');\n        }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('cold observable cannot have unsubscription marker \"!\"');\n        }\n        const messages = TestScheduler.parseMarbles(marbles, values, error);\n        const cold = new ColdObservable(messages, this);\n        this.coldObservables.push(cold);\n        return cold;\n    }\n    createHotObservable(marbles, values, error) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('hot observable cannot have unsubscription marker \"!\"');\n        }\n        const messages = TestScheduler.parseMarbles(marbles, values, error);\n        const subject = new HotObservable(messages, this);\n        this.hotObservables.push(subject);\n        return subject;\n    }\n    materializeInnerObservable(observable, outerFrame) {\n        const messages = [];\n        observable.subscribe((value) => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createNext(value) });\n        }, (err) => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createError(err) });\n        }, () => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createComplete() });\n        });\n        return messages;\n    }\n    expectObservable(observable, unsubscriptionMarbles = null) {\n        const actual = [];\n        const flushTest = { actual, ready: false };\n        const unsubscriptionFrame = TestScheduler\n            .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;\n        let subscription;\n        this.schedule(() => {\n            subscription = observable.subscribe(x => {\n                let value = x;\n                // Support Observable-of-Observables\n                if (x instanceof Observable) {\n                    value = this.materializeInnerObservable(value, this.frame);\n                }\n                actual.push({ frame: this.frame, notification: Notification.createNext(value) });\n            }, (err) => {\n                actual.push({ frame: this.frame, notification: Notification.createError(err) });\n            }, () => {\n                actual.push({ frame: this.frame, notification: Notification.createComplete() });\n            });\n        }, 0);\n        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n        }\n        this.flushTests.push(flushTest);\n        return {\n            toBe(marbles, values, errorValue) {\n                flushTest.ready = true;\n                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);\n            }\n        };\n    }\n    expectSubscriptions(actualSubscriptionLogs) {\n        const flushTest = { actual: actualSubscriptionLogs, ready: false };\n        this.flushTests.push(flushTest);\n        return {\n            toBe(marbles) {\n                const marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;\n                flushTest.ready = true;\n                flushTest.expected = marblesArray.map(marbles => TestScheduler.parseMarblesAsSubscriptions(marbles));\n            }\n        };\n    }\n    flush() {\n        const hotObservables = this.hotObservables;\n        while (hotObservables.length > 0) {\n            hotObservables.shift().setup();\n        }\n        super.flush();\n        const readyFlushTests = this.flushTests.filter(test => test.ready);\n        while (readyFlushTests.length > 0) {\n            const test = readyFlushTests.shift();\n            this.assertDeepEqual(test.actual, test.expected);\n        }\n    }\n    static parseMarblesAsSubscriptions(marbles) {\n        if (typeof marbles !== 'string') {\n            return new SubscriptionLog(Number.POSITIVE_INFINITY);\n        }\n        const len = marbles.length;\n        let groupStart = -1;\n        let subscriptionFrame = Number.POSITIVE_INFINITY;\n        let unsubscriptionFrame = Number.POSITIVE_INFINITY;\n        for (let i = 0; i < len; i++) {\n            const frame = i * this.frameTimeFactor;\n            const c = marbles[i];\n            switch (c) {\n                case '-':\n                case ' ':\n                    break;\n                case '(':\n                    groupStart = frame;\n                    break;\n                case ')':\n                    groupStart = -1;\n                    break;\n                case '^':\n                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    subscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                case '!':\n                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                default:\n                    throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n                        'subscription marble diagram. Found instead \\'' + c + '\\'.');\n            }\n        }\n        if (unsubscriptionFrame < 0) {\n            return new SubscriptionLog(subscriptionFrame);\n        }\n        else {\n            return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n        }\n    }\n    static parseMarbles(marbles, values, errorValue, materializeInnerObservables = false) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('conventional marble diagrams cannot have the ' +\n                'unsubscription marker \"!\"');\n        }\n        const len = marbles.length;\n        const testMessages = [];\n        const subIndex = marbles.indexOf('^');\n        const frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n        const getValue = typeof values !== 'object' ?\n                (x) => x :\n                (x) => {\n                // Support Observable-of-Observables\n                if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n                    return values[x].messages;\n                }\n                return values[x];\n            };\n        let groupStart = -1;\n        for (let i = 0; i < len; i++) {\n            const frame = i * this.frameTimeFactor + frameOffset;\n            let notification;\n            const c = marbles[i];\n            switch (c) {\n                case '-':\n                case ' ':\n                    break;\n                case '(':\n                    groupStart = frame;\n                    break;\n                case ')':\n                    groupStart = -1;\n                    break;\n                case '|':\n                    notification = Notification.createComplete();\n                    break;\n                case '^':\n                    break;\n                case '#':\n                    notification = Notification.createError(errorValue || 'error');\n                    break;\n                default:\n                    notification = Notification.createNext(getValue(c));\n                    break;\n            }\n            if (notification) {\n                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification });\n            }\n        }\n        return testMessages;\n    }\n}\n//# sourceMappingURL=TestScheduler.js.map",null]}