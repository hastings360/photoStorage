{"remainingRequest":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/observable/dom/WebSocketSubject.js","dependencies":[{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/rxjs/_esm2015/observable/dom/WebSocketSubject.js","mtime":1531331966000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/cache-loader/dist/cjs.js","mtime":1531332486000},{"path":"/Users/hastingsl/Documents/Web_Sites/photoStorage/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["import { Subject, AnonymousSubject } from '../../Subject';\nimport { Subscriber } from '../../Subscriber';\nimport { Observable } from '../../Observable';\nimport { Subscription } from '../../Subscription';\nimport { root } from '../../util/root';\nimport { ReplaySubject } from '../../ReplaySubject';\nimport { tryCatch } from '../../util/tryCatch';\nimport { errorObject } from '../../util/errorObject';\nimport { assign } from '../../util/assign';\n/**\n * We need this JSDoc comment for affecting ESDoc.\n * @extends {Ignored}\n * @hide true\n */\nexport class WebSocketSubject extends AnonymousSubject {\n    constructor(urlConfigOrSource, destination) {\n        if (urlConfigOrSource instanceof Observable) {\n            super(destination, urlConfigOrSource);\n        }\n        else {\n            super();\n            this.WebSocketCtor = root.WebSocket;\n            this._output = new Subject();\n            if (typeof urlConfigOrSource === 'string') {\n                this.url = urlConfigOrSource;\n            }\n            else {\n                // WARNING: config object could override important members here.\n                assign(this, urlConfigOrSource);\n            }\n            if (!this.WebSocketCtor) {\n                throw new Error('no WebSocket constructor can be found');\n            }\n            this.destination = new ReplaySubject();\n        }\n    }\n    resultSelector(e) {\n        return JSON.parse(e.data);\n    }\n    /**\n     * Wrapper around the w3c-compatible WebSocket object provided by the browser.\n     *\n     * @example <caption>Wraps browser WebSocket</caption>\n     *\n     * let socket$ = Observable.webSocket('ws://localhost:8081');\n     *\n     * socket$.subscribe(\n     *    (msg) => console.log('message received: ' + msg),\n     *    (err) => console.log(err),\n     *    () => console.log('complete')\n     *  );\n     *\n     * socket$.next(JSON.stringify({ op: 'hello' }));\n     *\n     * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>\n     *\n     * import { w3cwebsocket } from 'websocket';\n     *\n     * let socket$ = Observable.webSocket({\n     *   url: 'ws://localhost:8081',\n     *   WebSocketCtor: w3cwebsocket\n     * });\n     *\n     * socket$.subscribe(\n     *    (msg) => console.log('message received: ' + msg),\n     *    (err) => console.log(err),\n     *    () => console.log('complete')\n     *  );\n     *\n     * socket$.next(JSON.stringify({ op: 'hello' }));\n     *\n     * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object\n     * @return {WebSocketSubject}\n     * @static true\n     * @name webSocket\n     * @owner Observable\n     */\n    static create(urlConfigOrSource) {\n        return new WebSocketSubject(urlConfigOrSource);\n    }\n    lift(operator) {\n        const sock = new WebSocketSubject(this, this.destination);\n        sock.operator = operator;\n        return sock;\n    }\n    _resetState() {\n        this.socket = null;\n        if (!this.source) {\n            this.destination = new ReplaySubject();\n        }\n        this._output = new Subject();\n    }\n    // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures\n    multiplex(subMsg, unsubMsg, messageFilter) {\n        const self = this;\n        return new Observable((observer) => {\n            const result = tryCatch(subMsg)();\n            if (result === errorObject) {\n                observer.error(errorObject.e);\n            }\n            else {\n                self.next(result);\n            }\n            let subscription = self.subscribe(x => {\n                const result = tryCatch(messageFilter)(x);\n                if (result === errorObject) {\n                    observer.error(errorObject.e);\n                }\n                else if (result) {\n                    observer.next(x);\n                }\n            }, err => observer.error(err), () => observer.complete());\n            return () => {\n                const result = tryCatch(unsubMsg)();\n                if (result === errorObject) {\n                    observer.error(errorObject.e);\n                }\n                else {\n                    self.next(result);\n                }\n                subscription.unsubscribe();\n            };\n        });\n    }\n    _connectSocket() {\n        const { WebSocketCtor } = this;\n        const observer = this._output;\n        let socket = null;\n        try {\n            socket = this.protocol ?\n                new WebSocketCtor(this.url, this.protocol) :\n                new WebSocketCtor(this.url);\n            this.socket = socket;\n            if (this.binaryType) {\n                this.socket.binaryType = this.binaryType;\n            }\n        }\n        catch (e) {\n            observer.error(e);\n            return;\n        }\n        const subscription = new Subscription(() => {\n            this.socket = null;\n            if (socket && socket.readyState === 1) {\n                socket.close();\n            }\n        });\n        socket.onopen = (e) => {\n            const openObserver = this.openObserver;\n            if (openObserver) {\n                openObserver.next(e);\n            }\n            const queue = this.destination;\n            this.destination = Subscriber.create((x) => socket.readyState === 1 && socket.send(x), (e) => {\n                const closingObserver = this.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                if (e && e.code) {\n                    socket.close(e.code, e.reason);\n                }\n                else {\n                    observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +\n                        'and an optional reason: { code: number, reason: string }'));\n                }\n                this._resetState();\n            }, () => {\n                const closingObserver = this.closingObserver;\n                if (closingObserver) {\n                    closingObserver.next(undefined);\n                }\n                socket.close();\n                this._resetState();\n            });\n            if (queue && queue instanceof ReplaySubject) {\n                subscription.add(queue.subscribe(this.destination));\n            }\n        };\n        socket.onerror = (e) => {\n            this._resetState();\n            observer.error(e);\n        };\n        socket.onclose = (e) => {\n            this._resetState();\n            const closeObserver = this.closeObserver;\n            if (closeObserver) {\n                closeObserver.next(e);\n            }\n            if (e.wasClean) {\n                observer.complete();\n            }\n            else {\n                observer.error(e);\n            }\n        };\n        socket.onmessage = (e) => {\n            const result = tryCatch(this.resultSelector)(e);\n            if (result === errorObject) {\n                observer.error(errorObject.e);\n            }\n            else {\n                observer.next(result);\n            }\n        };\n    }\n    /** @deprecated internal use only */ _subscribe(subscriber) {\n        const { source } = this;\n        if (source) {\n            return source.subscribe(subscriber);\n        }\n        if (!this.socket) {\n            this._connectSocket();\n        }\n        let subscription = new Subscription();\n        subscription.add(this._output.subscribe(subscriber));\n        subscription.add(() => {\n            const { socket } = this;\n            if (this._output.observers.length === 0) {\n                if (socket && socket.readyState === 1) {\n                    socket.close();\n                }\n                this._resetState();\n            }\n        });\n        return subscription;\n    }\n    unsubscribe() {\n        const { source, socket } = this;\n        if (socket && socket.readyState === 1) {\n            socket.close();\n            this._resetState();\n        }\n        super.unsubscribe();\n        if (!source) {\n            this.destination = new ReplaySubject();\n        }\n    }\n}\n//# sourceMappingURL=WebSocketSubject.js.map",null]}